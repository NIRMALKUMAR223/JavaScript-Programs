scalable - means size / large amount of data
mongo duplicate is  also allowed

A - it will responsible for entire transaction(failure)
C - 5000 not more or not less how much data is required that much will be provided
I - other document are distrubing or not
D - once done transaction it update data is refelect in the Database


    sql                                 vs                              Nosql

It is RDBMS                                            It is Distributed Database or Nosql Database or Non-relationaldatabase

sql has Fixed schema or static schema                  It has Dynamic schema or schema less

It is suitable for complex queries                     It is not suitable for complex queries

sql supports ACID properties                           No-sql doesn't supports ACID properties

sql is vertically scalable                             No-sql is horizontal scalable

example:                                               example:
    mysql, oracle, sqllite, mssql etc                       mongo db, dynamo db, Hbase, couch db, redis etc




Nosql is a type of database management system (DBMS) that is designed to handle and store large 
volume of unstructured and semi-structed data.



Nosql database are generally classified into four main categories:

Document Database:

    * A document database stores data in json, bson, or XML document. 
    * Document in the database can be nested.
    * Document database are mongo db, apache, couch db.

Key-value stores:

    * This is the simplest type of Nosql database . 
    * Every element stored in key value pair consisting of an attributes name ('key') and value.
    * key-value database are amazon, redis, memecached, dinamodb.

column-family store / wide-column store:

    * while an RDBMS stores data in row and reads it row and reads it row by row, 
    * column-oriented database are organized as a set of columns.
    * wide-column database are cassandra, H-base.

Graph database:

    * A Graph database focuses on the relationship between data element . 
    * Each element is contained as a node. the connections between element in the database are called links or relationship. 
    * Graph database are Neo4j.


ACID properties in DBMS

Atomicity:

    * The entire transaction take place at once or doesn't happen at all.

Consistency:

    * The database must be consistent before and after the transaction.

Isolation:

    * Multiple transaction occur independently without interference.

Durability:

    * The changes of a successful transaction occur even is the system failure occur.


what is json ? 

    * JSON stands for javascript object notation.
    * JSON is a open source data-interchange format.
    * JSON is lightweight and self-describing.
    * JSON oriented from javascript.
    * JSON is easy to write.
    * JSON is language independent.
    * JSON supports data structures such as array and object.

what is bson ?

    * BSON stands for binary JSON.
    * It is almost similar to JSON.
    * It has limited datatype.
    * Data stored in the form of binary
    * It is more faster than JSON.
    * BSON can be understand only by machine where JSON can be understand only by humans.


founders of mongodb
 
    * eliot horrowitz
    * dweight marriman
    * kevin rayan

MongoDB:

    * mongodb was introduced in the year of 2007 
    * The first version released in the year 2009 mongodb 1.0
    * It is cross platform, document based, open source, Distributed database
    * It was written in c++
    * It supports horizontal scaling, flexible, indexing, sharding, replica set. 
    * If we want to store huge data mongodb is a best choice.

collection:

    * Collection is group of mongodb document.
    * It is the equivalent of an RDBMS table.
    * A collection exists within database.
    * Collection do not have a particular schema.
    * Document within a collection can have different fields.

Document: 

    * A document is set of key-value pair.
    * Representation of document is curly braces {}.
    * Document have dynamic schema.
    * Common fields in the document may hold different type of data.
    * Maximum size of each document is 16mb.

Capped Collection:

    * When we want to restict the size of capped collection the we go for capped collection.
    * Fixed size collection are called capped collection in mongodb. 
    * While creating a collection user must specify the collection's max size in 
      bytes and max number of document to store.

    example:

        db.createCollection('mytrainer', {capped : true, size : 10000, max : 2})

        To check wheather capped_collection is created or not

        syntax: db.collectionName.isCappped()

Objectid:

    * objectid will be generated by default at the time of field insertion.
    * objectid is unique and it acts like a primary key for particular field.
    * It is a 12 byte BSON type hexadecimal string.
    

    example:

        ObjectId('650c81b431bed4032b4')
        4 bytes: TimeStamp
        5 bytes: Random_Value
        3 bytes: increment

To read the document in mongodb we have 2 methods

find()

    * It is a primary method for retrieving documents form a collection in mongodb.
    * This method accepts a query object. if left empty all the document will be returned.
    * If no matching document is found, it return empty space.
    * If no data present in collection it will return empty space.

    syntax: db.collection.find({query},{projection}) 

        query : This is the filter criteria to specify which documents you want to retrive.
        projection : This define which fields to to include or exclude fro the result. if not specified all fields will be returned by default.

        example: To retrive all the documents

            db.student.find({}) or db.student.find()

            To retrive documents where age is 18

            db.student.find({age:18})

findOne()

    * To select only one document we can use the findOne() method.
    * This method accepts a query object. if left empty, it will return the first document it find in the collection.
    * It return only one document , even if Multiple document match the criteria.
    * If no matching document is found it will return null.

    syntax: db.collection.findOne({query},{projection}) 

        query:
        projection: 
            
            To retrive first document in collection.

            db.student.findOne({}) or db.student.findOne()
            
            To retrive the first matching document where age is 18.

            db.student.findOne({age : 18})

Operations:

    Operations are special symbols which are used to perfom specific tasks between two or more operands.

Query Operator:

    Query Operator in mongodb are used to filter document based on some specific criteria within their fields.

    $eq : matches the values of the field that equal to a specified value.

        Syntax: {field : { $eq : value} } or {field : value}

        example : db.emp.find({gender: {$eq: male}})

    $ne : matches all the values of the field that are not equal to a specified value.

        db.emp.find({gender : {$eq : male}})

    $gt : matches the value of the fields that are greater than a specified value.

        db.emp.find({age : {$gt: 20}})

    $gte : matches the value of the field that are greater than equal to the specified value.

        db.emp.find({age : {$gte: 1000}})

    $lt : matches the value of the field that are lesser than a specified value.

        db.emp.find({age : {$lt: 3000}})

    $lte : matches the value of the field that are less than equal to the specified value.

        db.emp.find({age : {$lte: 3000}})

    $in : matches the values specified in an array. 

    syntax : db.emp.find({age : {$in: [<value>, <value>, <value>, <value>]}})

        db.emp.find({sal : {$in : [5000, 1500]}})

    $nin : matches none of the values specified in an array.

    syntax : db.emp.find({age : {$nin: [<value>, <value>, <value>, <value>]}})

        db.emp.find({sal : {$in : [5000, 1500]}})

Logical operator:

    $and : 

        It is used to perform Logical AND operation of array of one or more expressions.
        All the conditions should br true.

        syntax: { $and: [ {Expersion1}, {Expersion2} .... {ExpersionN} ] }  or 
                { {Expersion1}, {Expersion2} .... {ExpersionN} }

    $or : 

        * It is one of the logical operator of an array of one or more expressions.
        * The $or operator perform a logical "OR Operation" an array of one or more <expressions> and selects the documents that satsisfy 
          at least one of the <expressions>.
        * Any one condition is satsisfy thats enough.

        syntax: { $or: [ {Expersion1}, {Expersion2} .... {ExpersionN} ] } 

    $nor : 

        * The $nor Operator is used to perform logical "NOR operations" on an array of one or more expression.
        * The operator is also used to select or retrive document that do not match all of the given expressions in the array.

        syntax: { $nor: [ {Expersion1}, {Expersion2} .... {ExpersionN} ] } 

    $not : 

        * The $not operator is used to perform logical "NOT operation" on the specificed expressions.
        * You can used it with any other query expression, such as equal to ($eq), greater than ($gt), lesser than ($lt).
        * It select or retrive only those document that do not match the given expression.

        syntax: { field { $not: { operator-expression } }}

Element Query operator

    Element operator return data based on field existence or datatypes.

    $exist :

        * The $exist operator match document that contain or do not contain a specificed field, including document where the field
          including document where the field value is null.

        syntax:  {field : {$exist : <boolean> }}

    $type :

        * $type select the document where the value of the field is an instance of the specified BSON types(s).
        * Query by data type is usedful when dealing with highly unstructed data where data types are not predictable.

        syntax: {field: {$type : <BSON type>}}

Evaluation operators:

    Evaluation operator return data based on evaluations or either individual fields or the entire collection document.

    $exper:

        * The $exper operator is used to allow the use of aggregation expression within query operations.
        * You can compare two fields in the same document.


Evaluation Operators:

--> It returns data based on evaluations of either individual fields or the entire collection's documents

$expr:

>> The $expr operator is used to allow the use of aggregation expressions within query operations

>> You can compare two fields in the same documents

>> $expr can contain expressions thar compare fields from the document

Syntax: {$expr:{<expressions>}}

Ex: db.emp.find({$expr:{$gt:{"$comm","$sal"}}})

$regex:

>> Provides regular expression capabilities for pattern matching strings in queries

Syntax: {<field>:{$regex:/pattern/}}

Ex: db.emp.find({ename:{$regex:/s/}})

Array Operators:

--> It can return data based on array condition

$all:

>> The $all operator selects the documents where the value of a field is an array that contains all the specified elements

Syntax:

{<field>:{$all:{<value1>,<value2>,...}}}

Ex:  db.emp.find({skills:{$all:{"Java","MongoDB","RDBMS"}}})

$elemMath:

--> The $elemMatch operator match documents that contain an array field with at least one element that matches all the specified query criteria

Syntax: {<field>:{$elemMatch:{<query1>,<query2>,....}}}

Ex: db.emp.find({grades:{$elemMatch:{score:90,rank:'A'}}})

db.emp.find({skills:{$elemMatch:{$in:{"Java","MongoDB","RDBMS"}}}})

$size:

--> The $size operator matches any array with the number of elements specified by the argument

Syntax: {field:{$size:Number}}

Ex: db.emp.find({skills:{$size:3}})

Projection Operators:

--> Projection Operators specify the field returned by an operation

$:

>> The positional $ operator limits the contents of an <array> to return the first element that matches the query condition on the array

Syntax: db.collection.find({<array>:<condition>...},{"<array>.$":1})

        db.collection.find({<array.field>:<condition>...},{"<array>.$":1})

Ex:  db.emp.find({skills:"Java"},{"skills.$":1})

     db.emp.find( (grades: ($elemMatch: ($cort 80), [rank: 'B']}], ["grades.S":1})


Arithemetic operations

    it is used to perform Arithemetic operation on number

    $add :

        It is used to add the two or more numbers and date also.

        syntax : {$add : [<expression1>, <expression2>,... ]}

        example : WAQTD total sal ( sal + comm ) of all employees along with name.

            db.emp.find({},{_id:0, ename:1, total_sal: {$add:['$sal','$comm']}})

        note : in case of comm is null 

            db.emp.find({},{_id:0, ename:1, total_sal: {$add:[ {$ifNull:['$comm',0]},'$sal']}})

                                        or

            db.emp.find({},{_id:0, ename:1, total_sal: {$sum:['$sal','$comm']}})

    $subtract :

        It is operator is used to subtract two numbers or date and return the difference.

            1. If the argument is the number the result will come in a number.
            2. If the argument is the two dates the result will come in milliseconds.
            3. If the argument is date and number in milliseconds , the result will come in date.

        syntax : {$subtract: [<expression1>,<expression2>]}

        example : WAQTD ename with 100 penalty from each employee salary.

            db.emp.find({},{_id:0, sal_aft_penalty: {$subtract :['$sal',100]}})
            
    $multiply :

        It is operator is used to multiply two or more number and return the result.

        syntax : {$multiply: [<expression1>,<expression2>,...]}

        example : WAQTD employee name along with their annul sal.

            db.emp.find({},{_id:0, sal_aft_penalty: {$multiply :['$sal',12]}})
            
        example : WAQTD employee name along with their annul sal with 20% hike.

            db.emp.find({},{_id:0, sal_aft_hike: {$multiply :[{$multiply : ['$sal',12]}, 1.2]}})
            
        example : WAQTD employee name along with their annul sal detection of 30%.

            db.emp.find({},{_id:0, sal_aft_hike: {$multiply :[{$multiply:['$sal',12]},0.7]}})


    $divide :

        It is also used to divide one number by another and return the result.

        syntax : {$divide: [<expression1>,<expression2>,...]}

        example : WAQTD employee name along with their daily salary.

            db.emp.find({},{_id:0, daily: {$divide :['$sal',30]}})

        example : WAQTD employee name along with half-month salary.

            db.emp.find({},{_id:0, half_sal: {$divide :['$sal',2]}})

    $mod :

        The $mod operator is used to divide one number by another number and return the remainder
        In other words the first number is the dividend and the second number is the divisor

        syntax : {$mod: [<expression1>,<expression2>,...]}

        example : WAQTD employee ename and salary those who re earning even salary

            db.emp.find({sal:{$mod:[2,0]}},{_id:0,ename:1,sal:1})
        
        example : WAQTD employee ename and salary those who re earning odd salary

            db.emp.find({sal:{$mod:[2,1]}},{_id:0,ename:1,sal:1})

        example : WAQTD document of employee where their empno manager number deptment number and salary is even

            db.emp.find({$and: [
                {empno: {$mod:[2,0]}},
                {mgr: {$mod:[2,0]}},
                {deptno: {$mod:[2,0]}},
                {sal: {$mod:[2,0]}},                
            ]}, {_id:0, ename:1,mgr:1,deptno:1, sal:1}) 

Data Modeling

    Most important topic in database

        Data Modeling is an process of defining how data is stored and what relationships exist between different entites in 
        our data.
        It aim to visually represent the relationship between different entities in data.

    Advantage:

        Easy to Manage data
        Less Memory
        Easily we can query on data
        Less Cost

    Types of data model:

        Embeded data model:

            It capture relationship between data by storing related data in a single document structure 
            It is a single structure
            It is also called de-normalized model
            It can store only 16 mb document
            It leads duplication of data

        Reference data model

            Reference store relationship between data by including links called Reference , from one document to another document
            This is most widely used data Modeling
            Here we need more than one document to store data either in same collection or different collection

    Relationships:

        A relationship is an connection between two documents.
        Relationships allow you to reference and query related documents in read and write operations.
        MongoDB relationship are the Representation of how the multiple document are logically connected to each other in mongodb.
        The Embeded and reference method are two ways to create such relationship.

        Types of relationship 

        * one to one relationship using embeded data model
            
            db.student.insertOne(
                                   {
                                   name:'nirmal',
                                   stdId:101,
                                   college:'kit-cbe',
                                   address:{
                                       'd/no': 1,
                                       street:'btm',
                                       city:'blr',
                                       pincode:560076
                                   }
                                   }
                               );

        * one to one relationship using reference data model
            
            db.student.insertOne(
                                   {
                                   name:'nirmal',
                                   stdId:101,
                                   college:'kit-cbe',
                                    }
            )
            
            db.studentAddress(
                {
                    address:{
                               'd/no': 1,
                               street:'btm',
                               city:'blr',
                               pincode:560076
                            }
                }
            )

            db.student.updateOne(
                {
                    name:'nirmal'
                },
                {
                    $set:{
                        address:ObjectId('17862372g32y3b823098')
                    }
                }
            )

            db.student.aggregate([
                {
                    $lookup:{
                        from:'studentAddress',
                        localField:'address',
                        forginField:'_id',
                        as:'address'
                    }
                }
            ])

        * one to many relationship using embeded

            db.student.insertOne({
                name:'jack',
                stdId:456,
                college:'his college',
                atmDetails:[
                    {
                        bankName:'union',
                        cardNo: 123434,
                        cvv:123,
                        expDate:'12/36'
                   },
                    {
                        bankName:'sbi',
                        cardNo: 432635,
                        cvv:874,
                        expDate:'12/26'
                   },
                    {
                        bankName:'union',
                        cardNo: 34343,
                        cvv:123,
                        expDate:'12/36'
                   }
                ]
            });

        one to many relationship using reference model

            db.student.insertOne({
                name:'jack',
                stdId:456,
                college:'his college',
            });

            db.studentAtm.insertMany(
                [
                    {
                        bankName:'union',
                        cardNo: 123434,
                        cvv:123,
                        expDate:'12/36'
                   },
                    {
                        bankName:'sbi',
                        cardNo: 432635,
                        cvv:874,
                        expDate:'12/26'
                   },
                    {
                        bankName:'union',
                        cardNo: 34343,
                        cvv:123,
                        expDate:'12/36'
                   }
                ]
            )

            db.student1.updateMany(
                {name:'jack'},
                {
                    $set:{atmDetails:[ObjectId(''),ObjectId(''),ObjectId('')]}
                }
            )

            db.student1.aggregate([
                {
                    $lookup:{
                        from:'studentAtm',
                        localField:'atmDetails',
                        foreginField:'_id',
                        as:'atmDetails'
                    }
                }
            ])

    Many to Many relationship 

        db.courses.insertMany([
            {
                courseName:'node js',
                duration:'2 month'
            },
            {
                courseName:'express js',
                duration:'2 month'
            },
            {
                courseName:'react js',
                duration:'2 month'
            }
        ])

        db.developers.insertMany([            
            {
                developerName:'jack',
                salary:10000
            },{
                developerName:'jacky',
                salary:10000
            },{
                developerName:'jeni',
                salary:10000
            },
            ])

        // developer id here in trainee as a reference 
        
        db.courses.updateOne(
            {courseName:'node js'},
            {$set:{trainee:[ObjectId(''),ObjectId('') ]}}
        )

        // courses id here in courses as reference
        
        db.developers.updateOne(
            {developerName:'jack;},
            {$set:{courses: [ObjectId(''), ObjectId(''), ObjectId('')]}}
        )

        db.courses.aggregate([
                {
                    $lookup:{
                        from : 'developers',
                        localField : 'trainee',
                        foreignField : '_id',
                        as : 'trainee'
                    }
                }
            ])

        db.developers.aggregate([
            {
                $lookup:{
                    from : 'courses',
                    localField : 'courses',
                    foreignField : '_id',
                    as : ''
                }
            }
        ])

    Schema : 

        * A schema is a JSON object that defines the structure and contents of your data.
        * It allow you to validate the structure of data.
        * It is used to specify validation rules for a document in a human readable format.

        Note : we can't create schema for admin, local, config database.

        Schema validation :

            * Schema validation lets you create validation rules for your fields such as allowed datatypes and value ranges.
            * MongoDB uses a flexible schema model, which means the document in an collection do not need to have the same fields or data
              types by default.
            
            How to create a schema ?

            db.createCollection('users',{
                validator:{
                    $jsonSchema :{
                        bsonType :'object',
                        required : ['username','password'],
                        properties : {
                            username:{
                                bsonType :'string',
                                description : 'must be string and its required'
                            },
                            password : {
                                bsonType :'string',
                                description : 'must be string and 8 char is required'
                            }
                        }
                    }
                }
            })

            db.createCollection('fruits', {
                validator:{
                    $jsonSchema:{
                        bsonType: 'object',
                        required :['name','price','quantity'],
                        properties:{
                            name:{
                                bsonType :'string',
                                description: 'name is mandatory'
                            },
                            price:{
                                bsonType : 'double',
                                description:'price is mandatory'
                            },
                            quantity:{
                                bsonType: 'number',
                                description:'quantity is mandatory'
                            }
                        }
                    }
                }
            })

            db.createCollection('phone',{
                validator:{
                    $jsonSchema : {
                        bsonType : 'object',
                        required : ['brand','model','price','manufacturing'],
                        properties : {
                            brand : {
                                bsonType : 'string',
                                description : 'brand is string data type'
                            },
                            model : {
                                bsonType : 'string',
                                description : 'model is string data type'
                            },
                            price : {
                                bsonType : 'double',
                                description : 'price in double data type'
                            },
                            manufacturing : {
                                bsonType : 'string',
                                description : 'manufacturing in string data type'
                            }
                        }
                    }
                }
            })

        // arrays and object  

            arrays : 

            db.createCollection('fruits',{
                validator : {
                    $jsonSchema : {
                        bsonType : 'object',
                        required : ['collection'],
                        properties : {
                            collection : {
                                bsonType : 'array',
                                items : {
                                    bsonType : ['string', 'number', 'object', 'double'],
                                    description : 'in array you can insert string, number, object, double datatype' 
                                }
                            }
                        }
                    }
                }
            })

            object : 

            db.createCollection('address',{
                validator : {
                    $jsonSchema : {
                        bsonType : 'object',
                        required : ['doorNo', 'street', 'city', 'pinCode'],
                        properties : {
                            doorNo : {
                                bsonType : 'number',
                                description : 'door number is number'
                            },street : {
                                bsonType : 'string',
                                description : 'street number is number'
                            },city : {
                                bsonType : 'string',
                                description : 'city number is number'
                            },pinCode : {
                                bsonType : 'number',
                                description : 'door number is number'
                            },
                        }
                    }
                }
            })

        // can we give schema for existing document 
            for that we have a command called  db.runCommand(collMod : collectionName,{})

            * If any collection is created and some data is present.
            * We can set schema later.